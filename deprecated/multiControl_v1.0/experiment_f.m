%%%%%%%%%%%%%%%%%% University of São Paulo - USP %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Author: Leonardo Borges Farçoni                       %%%%%%%%%%%%%%
%%%%%% e-mail: leonardo.farconi@gmail.com                    %%%%%%%%%%%%%%
%%%%%% Professor Advisor: Marco H. Terra and Roberto Inoue   %%%%%%%%%%%%%%
%%%%%% E-mail: terra@sc.usp.br and rsinoue@ufscar.br         %%%%%%%%%%%%%%
%%%%%% Date: July 10th, 2017                                 %%%%%%%%%%%%%%
%%%%%% Based on first code version by Isabella Cristina Souza%%%%%%%%%%%%%%
%%%%%% Faria (isamoreno2009@gmail.com) from January 20,2015  %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Revision 1:                                           %%%%%%%%%%%%%%

to=0;
te = str2double(get(gui.edit_time_exp,'string'))
td = str2double(get(gui.edit_time_traj,'string'))
dt = str2double(get(gui.edit_dt,'string'))
N = te/dt;

multirotor.setInitialPosition([x y z]);
multirotor.setInitialAttitude(multirotor.toQuaternion([theta_r theta_p theta_y]));
multirotor.reset();
multirotor.setTimeStep(dt/10); % Simulator 10x faster than controller dynamics

traj_opt = 1;
t = 0;
i = 0;
timerVal = tic;
displayStep = 0.1;
flag_exp = 1;
while(flag_exp == 1)%&& t<=te 
    i = i+1;
    
    t = t+dt;
    t_v(i) = t;

    %% Desired Trajectory Calculation
    s=[x;y;z];
    if traj_opt == 1  
        sf=[xf;yf;zf];
        dsf=[0;0;0];
        d2sf=[0;0;0];
        to = t;
        tf = to+td;
        [ax,ay,az] = trajectory_par_pol_f(dt,to,tf,s,ds,d2s,sf,dsf,d2sf);
        traj_opt = 0;
        % Yaw trajectory
        ayaw = par_pol_f(to,tf,theta_y,0,0,theta_y_d,0,0);
    end
    
    if t<=tf
        [xd,dxd,d2xd,d3xd] = traj_pol_f(ax,t,to);
        [yd,dyd,d2yd,d3yd] = traj_pol_f(ay,t,to);
        [zd,dzd,d2zd,d3zd] = traj_pol_f(az,t,to);
        [yawd,dyawd,d2yawd,d3yawd] = traj_pol_f(ayaw,t,to);
    end
    
    xd_v(i)=xd;
    yd_v(i)=yd;
    zd_v(i)= zd;
    dxd_v(i)=dxd;
    dyd_v(i)=dyd;
    dzd_v(i)= dzd;
    d2xd_v(i)=d2xd;
    d2yd_v(i)=d2yd;
    d2zd_v(i)=d2zd;
    
    %% Trajectory Control
    desiredPosition = [xd; yd; zd];
    desiredVelocity = [dxd; dyd; dzd];
    desiredAcceleration = [d2xd; d2yd; d2zd];
    position = [x; y; z];
    velocity = multirotor.previousVelocity();
    acceleration = (velocity - previousVelocity)/dt;
    error = desiredPosition-position;
    errorDerivative = desiredVelocity - velocity;
    error2Derivative = desiredAcceleration - acceleration;
    Tad = controller.force.kp'.*error+controller.force.kd'.*errorDerivative + controller.force.kdd'.*error2Derivative + multirotor.mass()*[0;0;9.81];
    
%     currentAttitude = multirotor.toEuler(multirotor.previousAttitude());
%     if abs(currentAttitude(1))>30*pi/180 || abs(currentAttitude(2))>30*pi/180
%         Tad = [0.001;0.001;0.001];
%     end
    
    previousVelocity = velocity;
    
    %% Desired Attitude Calculation
    % Calculate aircraft inverse control model
    Mf = forceMatrix(multirotor);
    Mt = torqueMatrix(multirotor,rotationDirection);
    H = [Mf;Mt]
    invMf = pinv(Mf);
    invMt = pinv(Mt);
    invH = pinv(H);    
    
    % Step 1 - Find desired force vector in the body frame at the desired
    % yaw direction
    qyd = [cos(yawd/2) 0 0 sin(yawd/2)];
    Qyd = matrixQ(qyd);
    invQyd = Qyd';
    Tcd = invQyd*Tad;
    % Step 2 - Calculates rotor speeds that generate that force vector,
    % forcing the aircraft to stay at hover
    [omega_square] = invMf*Tcd;
    % Step 3 - If any rotor speed is less than zero, assumes it is zero
    omega_square(omega_square<0) = 0;
    % Step 4 - Find the force vector that the aircraft is capable of
    % generating
    Tc = Mf*omega_square;
    % Step 5 - Find the attitude to align the force vector generated by
    % aircraft to the desired force vector
    Ta = Qyd*Tc;
    if norm(Ta)==0
        thetaCB = acos(([0 0 1]*Tad)/(norm(Tad)));
        vCB = cross(([0 0 1]'),(Tad/norm(Tad)));
    else
        thetaCB = acos((Ta'*Tad)/(norm(Ta)*norm(Tad)));
        vCB = cross((Ta/norm(Ta)),(Tad/norm(Tad)));
    end
    thetaCB = real(thetaCB);
    qCB = [cos(thetaCB/2) vCB'*sin(thetaCB/2)];
    % compound rotation -> desired attitude
    qd(1) = qCB(1)*qyd(1)-qCB(2)*qyd(2)-qCB(3)*qyd(3)-qCB(4)*qyd(4);
    qd(2) = qCB(1)*qyd(2)+qCB(2)*qyd(1)+qCB(3)*qyd(4)-qCB(4)*qyd(3);
    qd(3) = qCB(1)*qyd(3)-qCB(2)*qyd(4)+qCB(3)*qyd(1)+qCB(4)*qyd(2);
    qd(4) = qCB(1)*qyd(4)+qCB(2)*qyd(3)-qCB(3)*qyd(2)+qCB(4)*qyd(1);
    
    desiredAttitude = multirotor.toEuler(qd);
    theta_r_d_v(i) = desiredAttitude(1)*180/pi;
    theta_p_d_v(i) = desiredAttitude(2)*180/pi;
    theta_y_d_v(i) = desiredAttitude(3)*180/pi;
    
    %% Attitude Control
    % Calculates the torques necessary to position the aircraft at the desired attitude 
    [tau, P, error] = torqueControl(dt, qd, multirotor, controller);
    teste(:,:,i) = error;
    controller.P = P;
    %% Velocities of the rotors
    [omega_square]=invH*[Tc;tau];
    omega_square(omega_square<0) = 0;

    for j=1:multirotor.numberOfRotors()
        input(j,1) = rotationDirection(j)*sqrt(omega_square(j));
    end
    
    %% Simulates aircraft
    [t, output] = multirotor.run(input,[t-9*dt/10,t]);
    t = t(end);
    
    x=output(end,1);
    y=output(end,2);
    z=output(end,3);
    eulerAngles = multirotor.toEuler(output(end,4:7));
    theta_r=eulerAngles(1);
    theta_p=eulerAngles(2);
    theta_y=eulerAngles(3);
    
    x_v(i) = x;
    y_v(i) = y;
    z_v(i) = z;
    theta_r_v(i) = theta_r*180/pi;
    theta_p_v(i) = theta_p*180/pi;
    theta_y_v(i) = theta_y*180/pi;
    
    %% Displaces the quadrotor object
    plot_gui_graphics_f
    set(gcf,'CurrentAxes',gui.axes1)
    %  move_object_f(rmr_obj,[theta_r;theta_p;theta_y],[x;y;z]);
    move_object_f(quad1_obj,[theta_r;theta_p;theta_y],[x;y;z]);
    move_object_f(quad1_direcao,[theta_r_d_v;theta_p_d_v;theta_y_d_v],[x;y;z]);
    drawnow
    set(gcf,'CurrentAxes',gui.axes2)
    %  move_object_f(rmr_obj,[theta_r;theta_p;theta_y],[x;y;z]);
    move_object_f(multirotor_obj,[theta_r;theta_p;theta_y],[x;y;z]);
    move_object_f(multirotor_direcao,[theta_r_d_v;theta_p_d_v;theta_y_d_v],[x;y;z]);
    drawnow
    
    set(gui.edit_time,'string',t)
    
    set(gui.edit_posx,'string',x)
    set(gui.edit_posy,'string',y)
    set(gui.edit_posz,'string',z)
    
    set(gui.edit_roll,'string',theta_r*180/pi)
    set(gui.edit_pitch,'string',theta_p*180/pi)
    set(gui.edit_yaw,'string',theta_y*180/pi)
    
end
